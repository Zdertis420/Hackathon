Фильтры отображения для сетевых анализаторов (Wireshark, Paketyzer)
1. Фильтры отображения

Анализаторы трафика являются полезным и эффективным инструментом в жизни администратора сети, они позволяют «увидеть» то что на самом деле передается в сети, чем упрощают диагностику разнообразных проблем или же изучение принципов работы тех или иных протоколов и технологий.
Однако в сети зачастую передается достаточно много разнообразных блоков данных, и если заставить вывести на экран все, что проходит через сетевой интерфейс, выделить то, что действительно необходимо, бывает проблематично.
Для решения этой проблемы в анализаторах трафика реализованы фильтры, которые разделены на два типа: фильтры захвата и фильтры отображения. В прошлый раз мы рассматривали фильтры захвата. Сегодня пойдет речь о втором типе фильтров – о фильтрах отображения.
Фильтры отображения, это разновидность фильтров, позволяющая отобразить только те кадры, которые необходимы в данный момент (принадлежат определенному протоколу и/или узлу), временно скрыв все остальные.
Правила написания фильтров отображения отличаются от правил написания фильтров захвата. Отличая не такие уж большие, но как правило достаточные для того что бы правило фильтра захвата без каких-либо изменений не работало будучи примененным как фильтр отображения.


2. Синтаксис фильтров отображения

Выражение фильтра отображения состоит из набора специальных примитивов, которые строятся из так называемых классификаторов и идентификаторов объекта (адреса, имена объектов сети, номера портов).

Внимание: все классификаторы регистрозависимы и должны писаться только маленькими буквами.

Классификаторы в фильтре отображения не делятся на типы, в их качестве используются ключевые слова, соответствующие протоколам разных уровней модели OSI. Простейшим примером использования классификатора является имя протокола (ip, dns, arp и т.д.), введя которое в качестве фильтра отображения мы заставим программу оставить на экране только те кадры, которые содержат указанный протокол. При этом следует помнить, что в оперативную память попадают все захватываемые кадры, и отменив фильтр отображения вы сможете увидеть все карды, захваченные анализатором (все, прошедшие фильтр захвата).
Одним из отличий фильтров отображения является то, что можно производить доступ к определенным параметрам протокола, указывая название этого параметра через точку после имени протокола, например:

ip.dst
frame.pkt_len
tcp.port

И фактически, зачастую, написание фильтра отображения сводится к поиску правильного названия протокола или параметра этого протокола.
Для сравнения значений полей используются операторы сравнения:

eq, == – эквивалентно (равно)
ne, != – не эквивалентно (не равно)
gt, > – больше
lt, < – меньше
ge, >= – больше или равно
le, <= – меньше или равно

Все параметры протоколов (идентификаторы) – типизированы и зависят от конкретного параметра конкретного протокола.
Список допустимых типов идентификаторов следующий:

Без знаковое целое число (Unsigned integer), допустимы 8-ми, 16-ми, 24-х или 32-х битные значения
Целое (число) со знаком (Signed integer), допустимы 8-ми, 16-ми, 24-х или 32-х битные значения
Логический (Boolean)
Ethernet адрес (Ethernet address), 6 байт
Строка байт (Byte string), произвольное количество байт
IPv4 адрес (IPv4 address), 4 байта
IPv6 адрес (IPv6 address), 16 байт
IPX номер сети (IPX network number), 4 байта
Стока (String), произвольное количество символов
Число двойной точности с плавающей точной (Double-precision floating point number), 8 байт

Целые числа и адреса могут быть представлены как в десятичном, так и в шестнадцатеричном формате:

frame.pkt_len > 10 эквивалентно frame.pkt_len > 0xA
ip.src == 192.168.1.1 эквивалентно ip.src == 0xC0. 0xA8.0x1.0x1

В случае логических значений true эквивалентно 1 а false эквивалентно 0.
В аппаратных адресах числа могут разделяться символами двоеточия (:), точкой (.), тире (-):

eth.src == aa-aa-aa-aa-aa-aa
eth.src == aa:aa:aa:aa:aa:aa

IP адреса, так же как и числа, можно сравнивать между собой точно так же как и числа с использованием операторов сравнения eq, ne, gt, ge, lt, le.
В качестве адресов узлов можно вместо числовых адресов использовать символьные адреса, но при этом необходима доступная служба разрешения имен:

ip.dst eq www.habrahabr.ru
ip.src == 192.168.1.1

При описании сетей можно применять короткий вариант маски, так же можно применять маску и к символьным адресам:

ip.addr == 172.16.0.0/16
ip.addr eq server/24

Фильтр отображения может работать с примитивом proto [offset:size], как и фильтр захвата, но при его использовании есть некоторые отличия:

Как и в фильтрах захвата, в примитиве можно proto [offset:size] использовать отрицательные значения поля offset, но в этом случае выделяется указанный номер байта с конца кадра, а не байты предыдущих заголовков. Так же можно перечислять интересующие номера байт, использовать конструкции proto [offset:] и proto [:size].
К данным полученным с помощью примитива proto [offset:size] нельзя применять битовые операции, логические или арифметические операции
Данные, полученные с помощью примитива proto [offset:size] представляются в шестнадцатеричном виде.

Примеры использования примитива proto [offset:size] в расширенных фильтрах отображения:

eth.src[0:3] == AA:BB:CC – проверить на совпадение первые три байта заголовка (поле OUI в MAC адресе получателя).
frame[-4:4] == AA.BB.CC.DD – проверить последние четыре байта кадра.
proto[1,3-5,9:] == 01:03:04:05:09:0a — проверить 1, 3-5, 9 байты заголовка какого-то протокола.
eth.src[1-2] == AA:BB – проверить второй и третий байты поля заголовка на соответствие (эквивалент eth.src[1:2] == AA:BB).
eth.src[:4] == AA:BB:CC:DD – проверить первые четыре байта поля заголовка на соответствие (эквивалент eth.src[0:4] == AA:BB:CC:DD).
eth.src[4:] == 55:66 – проверить все байты поля заголовка, начиная с пятого на соответствие.

Все правила можно объединять логическими связками:

and, && — логическое «И»
or, || — логическое «ИЛИ»
xor, ^^ — логическое «Исключающее ИЛИ»
not, ! — инверсия, логическое «НЕ»

Например:

tcp.port == 110 and ip.src == 192.168.2.100 — IP адрес отправителя равен 192.168.2.100, используется протокол TCP и порт 110 (не важно, порт отправителя или получателя)
not udp — все кроме UDP дейтаграмм

При этом приоритет этих операций следующий:

наивысшим приоритетом обладает операция инверсии
потом логическое «И»
наименьшим приоритетом обладает операции «ИЛИ» и «Исключающее ИЛИ».

Как и в обычных математических выражениях, приоритет можно менять с использованием круглых скобочек (), действия в которых выполняются в первую очередь.


Внимание:
Следует быть осторожным при форматировании фильтров, описывающих требования к повторяющимся полям, например к IP адресам, так как в заголовке IP, IP адрес встречается дважды – адрес отправителя и адрес получателя. Следующие два фильтра, несмотря на кажущуюся одинаковость будут работать по разному:
ip.addr ne 1.1.1.1
not ip.addr eq 1.1.1.1
Первый фильтр означает «показать все кадры, в которых в заголовке IP пакета есть адрес, отличающийся от 1.1.1.1» и как следствие если адрес отправителя или адрес получателя будет другим, то кадр, содержащий такой заголовок будет отображен, несмотря на то, что второй адрес может совпадать с 1.1.1.1.
Второй вариант означает «показать все кадры, в которых в заголовке IP пакета нет адреса 1.1.1.1», таким образом для того что бы кадр был отображен требуется что бы ни адрес отправителя ни адрес получателя в IP заголовке не совпадал с 1.1.1.1.

Также следует быть аккуратным в правилах исключающих определенные пакеты. Например, мы хотим исключить из отображения все кадры, у которых в качестве IP адреса получателя стоит любой адрес кроме 1.1.1.1. Если применить следующий фильтр:
ip.dst ne 1.1.1.1
то из захвата действительно уберутся все кадры, в которых нет этого IP адреса получателя, а также те кадры в которых его и не могло быть (например, ARP). Если же нам нужен и не-IP трафик, то нужно исправить фильтр на такой:
not ip or ip.dst ne 1.1.1.1



3. Список протоколов и их параметров

Изучив основные правила написания фильтров отображения, остается разобраться только с тем, где найти список поддерживаемых протоколов и из параметров. Список протоколов и их параметров достаточно обширен и приводить его тут нет никакого смысла, его можно найти по ссылке на сайте wireshark.org

Удачного снифинга)